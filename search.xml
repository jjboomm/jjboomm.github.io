<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PHP数据类型（data type）笔记]]></title>
    <url>%2F2017-08-09%2Fphp%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[数据类型数据类型概念数据类型：data type。 在PHP中，数据类型指的是存储数据本身的类型，并不是变量的类型。PHP是一种弱类型语言，变量本身没有数据类型。 数据类型分类在PHP中，将数据分为三大类八小类： 简单（基本）数据类型：四小类 整型：int/integer，系统分配4个字节存储，表示整数型（有前提） 浮点型：float/double，系统分类8个字节存储，表示小数或整型存不下的整数 字符串型：string，系统根据实际长度分配，表示字符串（引号） 布尔类型：bool/boolean， 表示布尔类型，只有两个值：true和false 复合数据类型 对象类型：object，存放对象（面向对象） 数组类型：array，存储多个数据（一次性） 特殊数据类型 资源类型：resource，存放资源数据（PHP外部数据，如数据库、文件） 空类型：NULL，只有一个值：NULL，不能运算 类型转换类型转换：在一些条件下，需要使用特定数据类型，需要进行转换为目标数据类型。 PHP中有两种转换方式： 自动转换：系统根据需求自行判定，自行转换（用的较多，但效率偏低） 强制（手动）转换：人为的根据需要进行目标数据类型转换 在转换过程中，用的比较多的是转布尔类型（判断）和转数值类型（算术运算）。 自动转换：12345&lt;?php $a = '56.14561.152sawqe.qwe1wq6e3q.wqe'; $b = '45645646.486a4d65as4d'; echo $a+$b; //45645702.63161?&gt; 强制转换：12345&lt;?php $a = '56.14561.152sawqe.qwe1wq6e3q.wqe'; $b = '45645646.486a4d65as4d'; echo (int)$a+(int)$b; //45645702?&gt; 自动转换转换数值时： 以字母开头的字符串，被转换为0 以数字开头的字符串，碰到字母或第二个小数点为止，自动转换为整型或浮点型 数据类型判断通过一组以is_开头、后面跟类型名字的类型判断函数，如is_int($t)，来判断变量，返回这个变量所保存数据的数据类型判断结果，如果相同，返回true，否则返回false。 1234&lt;?php $s = 12345; var_dump(is_int($s)); //bool(true)?&gt; 获取和设定数据类型通过gettype()函数可以获取数据类型，得到的是该类型对应的字符串： 1234&lt;?php $s = 12345; echo gettype($s); //integer?&gt; 通过settype()函数可以设定数据类型， 但与强制转换不同的是，settype()直接将原始数据进行转换赋值，强制转换是将原始数据复制后转换： 123456&lt;?php $s = '12345.6'; var_dump($s); //string(7) "12345.6" settype($s, int); var_dump($s); //int(12345)?&gt;]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP常量（canst/canstant）笔记]]></title>
    <url>%2F2017-08-09%2FPHP%E5%B8%B8%E9%87%8F.html</url>
    <content type="text"><![CDATA[PHP基础-常量常量基本概念 常亮与变量一样，都是用来保存数据的。但与变量不同的是，常亮不能被重新赋值，也不能被unset()销毁。 常亮的赋值只能在定义时赋值。 有效的常量名以字符或下划线开头（常量名称前面没有$符号），由字母下划线和数字组成，一般使用大写命名，以便区分变量。 常量定义形式PHP中常量在5.3版本后有两种定义形式： 使用定义常量的函数：define(‘常量名’,’值’)； 使用定义常量的语法结构：const 常量名=值；(5.3版本以后才有) 1234&lt;?php define('PI', 3.14159); echo PI; //3.14159?&gt; 1234&lt;?php const PI = 3.14; echo PI; //3.14?&gt; 需要注意的是：define和const定义的常量是有区别的，区别在于访问权限。 const定义的常量大小写敏感，而define可以通过第三个参数（为true表示大小写不敏感）来指定大小写是否敏感。 ``` php&lt;?phpdefine(‘FOO’, ‘BAR’, true);echo FOO; // BARecho foo; // BAR?&gt;12345678#### 定义特殊变量 * 常量命名规则比较松散，可以使用一些特殊字符，但只能使用define()函数定义，且需要以constant(‘变量名’)来调用。``` php&lt;?php define(&apos;-_-&apos;, &apos;smile&apos;); const -_- = &apos;smile&apos;; //错误?&gt; 打印特殊变量12345&lt;?php define('-_-', 'smile'); echo -_-; //错误 echo constant('-_-');?&gt; 常量与变量的使用 凡是数据可能会发生变化的，一定使用变量。 数据不一定发生改变，可以使用常量或变量（变量居多）。 数据不允许被修改的，一定使用常量。 系统常量系统常量的概念系统常量，就是系统帮助用户定义的常量，用户可以直接使用。 常用的几个系统常量123PHP_VERSION:PHP版本号PHP_INT_SIZE:整型大小PHP_INT_MAX:整型能表示的最大数 几个特殊系统常量系统中存在一些由__（双下划线）开头并以__结尾的特殊系统变量，这种常量称之为魔术常量：魔术常量的值通常会根据环境变化。 123456__DIR__:当前被执行的脚本所在电脑的绝对路径__FILE__:当前被执行的脚本所在电脑的绝对路径(带自身文件名)__LINE__:当前所属的行数__NAMESPACE__:当前所属的命名空间__CLASS__:当前所属的类__METHOD__:当前所属的方法 123&lt;?php echo __DIR__;?&gt;]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Mac上部署Hexo+GithubPages]]></title>
    <url>%2F2017-08-09%2Fmac-hexo-githubpages.html</url>
    <content type="text"><![CDATA[由于接触Github不多，对Git命令也不是特别熟悉，本篇主要记录如何在Mac上部署Hexo来服务Github Pages。 Hexo什么是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Hexo安装 Hexo 相当简单。但Hexo依赖于nodejs，需安装nodejs，安装nodejs最好选择homebrew（homebrew安装依赖ruby），除此之外，还需要安装git。 安装顺序 homebrew nodejs git Hexo 安装homebrew1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装nodejsbrew install node 安装gitbrew install git 安装hexonpm install -g hexo-cli 初始化Hexo当hexo成功安装后，需要建立文件夹，进行初始化。 123mkdir blogcd bloghexo init 此时hexo初始化成功后，将会在blog文件夹中，生成hexo文件。我们进行测试： 12hexo ghexo s 根据提示，成功则可访问http://localhost:4000进行预览。 配置Github Pages在Github上新建一个Repository，并命名为xxxxx.github.io(xxxxx是Github的账号名)。 仓库建立完成后，打开blog/_config.yml文件配置Hexo和Github取得关联。 找到文件最下面： 1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 修改为： 12345deploy: type: git repository: https://github.com/xxxxx/xxxxx.github.io.git #部署的仓库的SSH branch: master #部署分支， 一般使用master主分支 message: update #默认类型 需要注意的是： 网上可能部分教程的type是github，但在Hexo3.0之后，必须填写git。 repository这个参数很重要，它就是用来链接github上创建的仓库。网上有的人使用SSH，但是SSH配置起来相对有些复杂，这里用的是HTTPS方式，也是可以成功的。 每个参数的：后面必须留有一个空格，否则会出现语法错误。如：type: git，在git之前就有一个空格。 修改完毕保存后，在终端中输入： npm install hexo-deployer-git --save 会出现信息：└── hexo-deployer-git@0.1.0，此时就可以把博客部署在Github Pages上了。 提交博客在终端中输入hexo d（d是hexo deployer的缩写），待终端出现INFO Deploy done: git就说明提交成功，打开浏览器访问xxxxx.github.io即可看到博客。 注意，本文中涉及到xxxxx请自行替换用户名。 Hexo简单用法hexo new “我的博客” 新建一篇文章 hexo g 生成文件 hexo d 部署 hexo clean 清除public文件夹下的文件(网页正常时无需使用此命令) 其他帮助可以查看： Hexo常用命令笔记 Hexo]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用kcptun对Shadowsocks进行加速]]></title>
    <url>%2F2017-02-05%2Fkcptun.html</url>
    <content type="text"><![CDATA[openvz类vps目前有效的加速方案就是kcptun、finalspeed、net_speeder这三种，其中finalspeed作者已宣布停止维护，而目前新出来最佳的工具无疑是Kcptun。 Kcptun 是一个非常简单和快速的，基于 KCP 协议的 UDP 隧道，它可以将 TCP 流转换为 KCP+UDP 流。而 KCP 是一个快速可靠协议，能以比 TCP 浪费10%-20%的带宽的代价，换取平均速度提高 30%-40%，且最大延迟降低三倍的传输效果。 Kcptun 是 KCP 协议的一个简单应用，可以用于任意 TCP 网络程序的传输承载，以提高网络流畅度，降低掉线情况。由于 Kcptun 使用 Go 语言编写，内存占用低，而且适用于所有平台，甚至 Arm 平台。 详细可以查看项目信息：KCP 协议：https://github.com/skywind3000/kcpKcptun 项目地址：https://github.com/xtaci/kcptun 对于BandwagonHost的Log_Angeles服务器，延迟基本上是美国服务器中最低的，正常情况下，不会超过200ms，一般情况是180-190ms，尽管拥有1G的网络端口，但是在使用Shadowsocks中还是不太理想，尝试使用kcptun对Shadowsocks进行加速。 为了排除其他因素，我选择了重新安装系统，在尝试Centos7 64位出现问题，我还是使用了Centos6 64位。新安装的系统要全部重新布置，包括：SSH，Shadowsocks和iptables防火墙。 在安装Shadowsocks我选择了Shadowsocks-libev 版，并使用了一键安装脚本。同样，安装kcptun时也选择使用了一键安装脚本。在此感谢脚本作者带来的便利！ 安装Shadowsocks-livec： 本脚本适用环境：系统支持：CentOS 32 或 64 位内存要求：≥128M日期：2016 年 11 月 05 日关于本脚本：一键安装 libev 版的 shadowsocks 最新版本。该版本的特点是内存占用小（600k左右），低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。 使用方法：使用root用户登录，运行以下命令： 123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.shchmod +x shadowsocks-libev.sh./shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log 安装完成后，脚本提示如下： 12345678910Congratulations, Shadowsocks-libev install completed!Your Server IP:your_server_ipYour Server Port:your_server_portYour Password:your_passwordYour Local IP:127.0.0.1Your Local Port:1080Your Encryption Method:aes-256-cfbWelcome to visit:https://teddysun.com/357.htmlEnjoy it! 卸载方法：使用 root 用户登录，运行以下命令： ./shadowsocks-libev.sh uninstall 安装完成后即已后台启动 Shadowsocks-libev ，运行： /etc/init.d/shadowsocks status可以查看进程是否启动。本脚本安装完成后，会将 Shadowsocks-libev 加入开机自启动。 使用命令：启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 查看状态：/etc/init.d/shadowsocks status 更为详细的使用请查看作者原博文：https://teddysun.com/357.html，还可以获取更多的一键安装脚本，再次感谢！ 安装kcptun：检查端口：首先需要检查加速地址和端口是否正常，非常重要！ 使用命令：netstat -nl | grep 8388 如果提示以上命令不存在，请输入：ss -nl | grep 8388 注意将以上的8388替换为你的Shadowsocks端口，当然，kcptun不止可以加速Shadowsocks。 然后你会看到类似下面的输出（着重看显示为红色的部分）： 情况一： 12tcp6 0 0 :::8388 :::* LISTEN udp6 0 0 :::8388 :::* 情况2： 12tcp 0 0 127.0.0.1:8388 :::* LISTEN udp 0 0 127.0.0.1:8388 :::* 情况3： 12tcp 0 0 0.0.0.0:8388 :::* LISTEN udp 0 0 0.0.0.0:8388 :::* 情况4（假如 10.10.10.10 是当前服务器IP）： 12tcp 0 0 10.10.10.10:8388 :::* LISTEN udp 0 0 10.10.10.10:8388 :::* 若为情况1、情况2和情况3，那么你的加速地址可以为：加速 IP 127.0.0.1，加速端口 8388（你的 Shadowsocks 端口） 若为情况4，那么你的加速地址为：加速IP 10.10.10.10（你的服务器IP），加速端口8388（你的 Shadowsocks 端口） 开始安装：123wget --no-check-certificate https://raw.githubusercontent.com/kuoruan/kcptun_installer/master/kcptun.shchmod +x ./kcptun.sh./kcptun.sh 接下来开始根据脚本提示设置kcptun 配置Kcptun设置 Kcptun 的服务端端口：12请输入 Kcptun Server 端口 [1-65535]:(默认: 29900): 请输入一个未被占用的端口，Kcptun 运行时将使用此端口。 设置加速的 IP：12请输入需要加速的 IP [0.0.0.0 ~ 255.255.255.255]:(默认: 127.0.0.1): 填入上面获取到的加速 IP，一般是默认，除非你是第四种情况。 设置需要加速的端口：[1-65535]:1(默认: 12948): 填入上面获取到的加速端口。 程序会检查当前是不是有程序占用着此端口，如果你的 Shadowsocks 没在运行，或者没有软件使用此端口，会弹出如下提示： 1当前没有软件使用此端口, 确定加速此端口?(y/n) 如果你确认 Shadowsocks 运行时会使用此端口，那么输入 “y” 回车即可，此时你应该检查Shadowsocks是否运行，以及端口占用情况（多半还有关于防火墙的原因）。 设置 Kcptun 密码：12请输入 Kcptun 密码:(如果不想使用密码请留空): 这就是说，你可以为 Kcptun 单独设置一个密码，防止被他人恶意使用。这个密码和 SS 的密码没有关系，请不要把它们混淆了。 再提一句，Kcptun 和 Shadowsocks 没有任何关系，请不要脑补它们之间存在任何联系，Kcptun 你可以理解为一款网络加速软件，只不过它是通过将 TCP 协议转换为 UDP 协议，然后再通过大量的发送数据包，浪费了带宽以换取网速的提升。它能加速所有以 TCP 协议传输数据的软件，不单单是 Shadowsocks。只是大家都用来……你懂的 回到上面的密码设置问题，如果你这里选择直接回车，也就是代表你不自定义密码。但是 Kcptun 有一个默认的密码，这个密码是： it’s a secrect 。 如果你这里选择不设置密码，那么客户端的参数里边就不需要加 –key 这一参数，但是 Kcptun 还是会用上面一个密码做默认值。 禁用压缩12是否禁用数据压缩?(默认: 不禁用) [y/n]: 这个选项是什么意思呢？Kcptun 默认是启用压缩的，也就是说是默认是n，如果你这里设置为 y，也就是配置为 nocomp:true，那么就是禁用压缩。 许多朋友这里设置的是保持默认（启用压缩），而偏偏在软件之中设置为禁用压缩（勾上对钩是禁用），当然就连不上咯。 其他配置项不用我说了，如果你了解它是干什么的，可以自定义配置。如果不知道，那么直接回车使用默认参数。 但是，使用默认参数，是有可能浪费大量流量的，你会发现你的流量像泄洪一样快速减少，你需要会调节参数，套用官方的说明。]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>kcptun</tag>
        <tag>shadowsocks</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言学习与开发的Sublime Text 3 与 gcc 配置记录]]></title>
    <url>%2F2017-01-09%2Fwindows-Sublime_Text_3-gcc.html</url>
    <content type="text"><![CDATA[本文记录Windows下的C语言开发环境（Sublime Text 3 + gcc）开发环境搭建，包括MinGW的安装，gcc运行c语言，在sublime中运行以及在cmd中运行的方法。 安装： MinGW Sublime Text 3 MinGW安装配置： MinGW是Minimalist GNU on Windows的首字母缩写，安装后就可以使用很多的GNU工具。GNU（GNU’s Not Unix）是linux中的一个著名的项目，包含了gcc\g++\gdb等工具。也就是说，安装MinGw后，我们就可以使用gcc和g++命令了。 由于官网下载方式需要网络安装，经过尝试最终还是由于网络原因安装失败，最终妥协后使用了网络下载的解压版MinGW 下载地址：MinGW百度云网盘下载 解压后，将MinGW文件夹放到C盘根目录，也就是“C:\MinGW\”。 此时我们还不能方便的在cmd中使用类似于“gcc 源文件名 -o 可执行文件名”的命令，我们需要在系统中配置环境变量。 右键计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量 添加“C:\MinGW\bin”到“Path” 注意：Windows环境变量的修改不会立即生效，需要重启Windows。 Sublime Text 3配置： Sublime Text 3无疑是众多码农的最爱，但Sublime Text 3只是一款编辑器，在C代码开发中，如果可以用Sublime Text 3调用gcc来完成编译运行，无疑是最好不过了。 在Sublime Text 3 中选择tool –&gt; Build System –&gt; New Build System，复制粘贴以下代码： 1234567891011121314&#123; &quot;working_dir&quot;: &quot;$file_path&quot;, &quot;cmd&quot;: &quot;gcc -Wall -fexec-charset=GBK \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;, &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;selector&quot;: &quot;source.c&quot;, &quot;variants&quot;: [ &#123; &quot;name&quot;: &quot;Run&quot;, &quot;shell_cmd&quot;: &quot;gcc -Wall -fexec-charset=GBK \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd /c \&quot;\&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;\&quot; &amp; pause\&quot;&quot; &#125; ]&#125; 需要注意的是，在gcc编译参数中，加入了“-Wall”和“-fexec-charset=GBK”，“-Wall”参数是打开常用的警告，“-fexec-charset=GBK”参数则是解决中文乱码问题，由于Sublime Text 3中文件默认编码格式是utf-8 ，而windows中的命令行默认编码格式是GBK 。所以代码中出现中文时运行会乱码。加入“-fexec-charset=GBK”选项后，代码中的字符串按照GBK编码，就和CMD窗口保持一致，便不会发生中文乱码问题。 但是加入这个选项后，如果要编译的不是utf-8 ，而是GBK ，必须还要加入-finput-charset=GBK 选项来制定源代码的编码格式，否则会提示错误，而加入这个选项后编译utf-8又会乱码，所以建议在Sublime Text中全部使用UTF-8编码格式。 按Ctrl+S保存，会自动打开user目录（Sublime Text 3\Packages\User），修改文件名为 C.sublime-build，保存在此目录。 这时候，可以在Tools -&gt; Build System下看到刚才新建的C了，选中后就可以使用了。 Build System中除了选择具体的编译系统，还可以选择第一个：Automatic 自动选择，会根据打开的文件后缀自动选择。 完成配置完成后，使用Ctrl+B和Ctrl+shift+B便可以编译运行了。 技术参考文章：http://www.yalewoo.com/sublime_text_3_gcc.html 在Windows下，我们还可以使用Dev C++来完成C语言代码，效果不错。看个人爱好。]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>Sublime Text 3</tag>
        <tag>gcc</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你喝过哪些曾经误导过你的「毒鸡汤」？]]></title>
    <url>%2F2016-08-23%2Fzhihu-dujitang.html</url>
    <content type="text"><![CDATA[一直以来，知乎在我心里是一个获取知识的圣地，虽也有人劝我“少去破乎”，可我依然不能放弃这个让我读过很多精彩回答的地方。此篇回答为转载，侵权删。 你很聪明，只要再努点力就好了有一句毒鸡汤，我相信在座的所有人都喝过，也许直到今天还被他深深毒害。 那就是——你很聪明，只要再努点力就好了。 FUCK，我知道跟我说这句话的人是出自好意，但你们知道这会害了我吗？因为 长期被评价为“很聪明，不用心”的孩子，能力往往配不上自己的野心，需要活在别人的夸奖中，从来不肯也做不到全力以赴。 小时候，每次开家长会时，妈妈都告诉我：“老师都说你挺聪明的，就是不努力，要是你努力起来不得了！ 我很高兴，因为我觉得只有笨人会选择勤奋，自己可以随时发力追赶笨人。只要稍微动一下就可以把笨人甩得远远的。 可惜这一天永远没有到来，等我真正发力的时候，我发现我与他们不仅天差地别，最绝望的一点则是——比起他们来，其实我很笨。 “你很聪明却不努力”这句话确实能安慰人，但却没有什么卵用。其实我们是这么想的：”是啊，我的确很聪明，就是不努力，努力太辛苦了，反正后面我随便发点力就可以超过他们了，我现在就暂时偷会懒吧！“ 我知道，老师这样说也迫于无奈，只是为了让那些孩子的家长，不会因为孩子的不优秀而伤心，是为了安慰家长，也是给孩子留一线希望。但老师们不明白，这句话只会让一个人更加不努力，满足于自己的“聪明”而沾沾自喜。 我们的”聪明“没有给我们带来帮助，当我们被生活逼入绝境时，我们再发力的时候，却发现我们并不聪明，而且比我们聪明的人，要比我们努力很多，或者正因为他们足够聪明，他们才懂得提前努力的好处。 鼓励不一定会让一个人进步，同时还会让一个人盲目。我们会自动否定那些比我们好的人，甚至隔绝和他们的来往。我们并不希望改掉弱点，尤其是我们的失败受到别人怜悯的时候。 “你很聪明”这朵鲜花，其实是摆在了自己的坟墓上。聪明如我们，用全身的本领证明了自己的愚蠢。 这次时代认为自己”聪明“的人，其实都是笨人。他们在人生的前半段也许还能混得开，可到了人生的下半场就开始由于缺乏持续的努力和对生活的追求，而把逼入平庸的境地。 自作聪明的人，往往还没有学会正视自己与他人的努力和付出，就已经喜欢上了那种轻盈获胜的姿态。为了姿态好看，他们宁可输，也不想通过努力制胜。 为什么？因为我们害怕假如自己拼尽全力还是不能取胜的话，那该有多丢人吧，所以我们活在这个名为“聪明却不努力的城堡”里，显然要安全得多。 也许这个世界上本来就没有聪明这个词，他是老师发明来安慰那些特立独行，很难说服自己专注开一件乏味事情的人。在追逐梦想这条路上聪明帮不了我们，而勤奋却可以。 在一个聪明人满街乱窜年代，稀缺的恰恰不是聪明，而是一心一意，孤注一掷，一条心，一根筋。 柏拉图说过：耐心才是一切聪明的基础。请别再说我聪明了，因为我只会为我的失败感到恶心。 醒悟吧 是的，当我读到这篇回答时，让我想起的就是我在那个该读书的年纪却一直玩耍还被老师这样“夸奖”的我。直到读了这篇回答，我才明白，为什么我如此“聪明”却还是不如大家。或许正是因为自己的某一方面天赋，“印证”了老师对你说的话，让你觉得自己确实是老师说的那种“聪明学生”。我在读小学的时候，成绩也算不错，特别是在小学毕业的时候，数学满分让我觉得大家说我聪明就是事实，可能正是因为这样让我在初中越来越懒惰，越来越不想学习，因为我觉得我加把劲还是可以追上大家的，可在我尝试去追赶大家的时候，我发现好像已经没有用了，一切都晚了，破罐子破摔吧。 早领悟，早回头，早享受。]]></content>
      <tags>
        <tag>知乎</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样成为全栈工程师？]]></title>
    <url>%2F2016-06-20%2FFull-Stack-Engineer.html</url>
    <content type="text"><![CDATA[作者：顾鹏链接：https://www.zhihu.com/question/22420900/answer/21770992来源：知乎（转载，侵权删。）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 做这样一个简单的 app:一个天气应用，干净清爽的界面，天气信息一目了然。它不仅可以精确预测未来 10 天的天气，还可以显示某地的历史天气信息。它具有自定义提醒功能，支持 web 版本， iOS 版， Android 版。 为什么想要做这样一个 App ？因为你喜欢旅行，但没找到一个天气 App 可以提供你下个月或者某个特定月份的天气信息；因为你懒你没有每天看天气预报的习惯，你想要在第二天温度达到 30 度以上或者温差有 +/-7 度的时候，获得温馨提示；因为你要成为一个 Full Stack Engineer ，你必须不断训练每个 stack 的能力。 Web版你决定用 MySql 来存储用户数据，用 NoSql 存储历史天气数据。你用 Redis 作为 cache ，缓存一些最常请求的天气数据。你用 Python 写后台，功能简单，后台不复杂，用户注册登录，抓取返回某城市的天气数据，某地的历史天气数据，很快便搞定。 后台开发并测试好了，接下来是 Web 前端。你十分清楚一个好的 UI 设计对一个 App 的重要性，你也明白 UI 的设计不只是为了美观，更重要的是提高信息的可读性和程序的可用性。幸好你平日的积累这次派上用场了。你把之前保存下来的上百个优秀的UI设计作品拿来研究，你从书架上拿出Norman 的那本经典 - The Design of Everyday Things 重新细读。最终你用白纸黑笔敲定了第一个版本的 UI，简洁直观，没有任何多余的设计，所有元素的排列间距 大小颜色都恰到好处。你相信即使天气不好，但用户只要使用这个 App 都会有着愉悦的心情。 那么开始写前端吧。啊，别急，都忘了还有 Icon 和 Logo ，可是不会 PS ，不会 AI ，不会 Sketch 怎么办呢，学吧。你平日喜欢结交不同领域的朋友，正好几周前在一个活动上你认识一位朋友做设计的。她花一个下午的时间教你基本的 Sketch 的使用，并对你的 UI 设计给出了一些意见。你请她吃了顿晚饭表示感谢，然后立即回家根据她的一些建议重新调整了 UI ，这次你在 PS 里把 UI 画了出来，Icons 和 Logo 也顺道一起做了。 接下来的一周，你学习 HTML，CSS，以及 Javascript，并漂亮地把前端搞定。 发布 App在朋友圈发了个状态，找人帮你做 Beta 测试。他们都首先问你是什么 App，一开始你简单回答一个天气的 App。但你发现，这不能提起他们的兴趣。你觉得你需要用语言，用故事包装一下。不光是作为别人「是什么 App」提问的回答，也是成为 Full stack Engineer 道路上的一个重要技能。 你去看了所有你喜欢的产品的主页，从他们的文案上获得一些灵感启发；你读了经典的 On Writing Well ，发现好的文案，好的设计，其实和好的代码很相似，都是重在交流，如何让他人毫不费劲地明白你要表达的内容。你的故事要吸引人，你的产品介绍要在1分钟内解释清楚，并确保你的父母可以毫无压力听明白。 一切就绪，产品上线了。反响不错，用户持续增加。很多用户希望有移动版本，于是你立即投入到iOS 版本的开发上。 iOS 版 及 后台优化你花一周不到时间学习了基本的语法和工具使用便投入到 App 的开发中。你知道 Learn by Doing 是最好也是最快的。由于之前学习了设计的基础，UI ，Icons 很快搞定，不久 iOS 版本便发布了。iOS 的发布带来了更多的用户增长，后台服务器的压力颇大，你知道是时候优化后台了。 你在 AWS 上多开了 2 台服务器，并写了一个 Script 来自动化部署过程。你改用 uWSGi 协议，用 uwsgi 作为 Application Server。你使用 Nginx 来做并发，负载均衡 …………… 成立公司用户持续增长，每天你都会收到十几二十封用户的邮件。你很感激这些愿意花时间给你写邮件的用户，你相信他们是你最重要的用户，是潜在的付费用户。如果你把他们像上帝一样对待，他们同样也会把你看作是上帝。所以除了睡觉时间的发来的邮件，每一封邮件，你都会在2小时内给予回复。 果然这样的付出是收获巨大的，他们不仅惊讶且非常感谢你的快速回复，他们会在app store里给你★★★★★的评价，他们在社交网站上分享你的app，他们甚至会主动提出捐款给你。 你从快速的用户增长中嗅到了商机，你开始思考如何赚钱。广告你是坚决不能允许的，你认为再精确的广告也会影响用户体验。你设计了 2 个不同的付费方案，你打算用 A/B 测试看哪个方案更好。你分别给 200 个用户发去邀请尝试付费的邮件，邮件内容你精心打磨过，并在最后写上：CEO &amp; Founder. 通过分析 2 种方案的用户行为，你决定将使用第一种方案。 接下来，你相信差不多是时候成立个公司了。为了省时间，你花 2000 块钱找了个园区挂靠并帮你注册公司。公司的名字让你头疼了很久，你不想只是简单的用这个 App 的名字作为公司名字，你知道公司将来还会做出其他优秀的产品。你希望这个名字简单易记，同时其含义也是你公司文化的象征。 公司注册下来了，但银行那边得自己跑。你联系了一些媒体编辑，邀请他们来试用你的产品；你重新设计了产品主页，并开始写产品的 Blog ；你在各大社交网络都给 App 注册了账号，即做社区客服也为宣传… 这些事大大压缩你写代码的时间。以往你都是以代码量作为衡量自己当天工作效率的指标，所以这些天你总感觉没做啥工作。 这样的发展早已超过你的预期，这个 App 从一个 Side Project 几乎变成了你生活的全部。你跟你女朋友半个月才出去约会一次，她抱怨不断；你1个月没跟朋友出去玩耍喝酒了；你 2 个月都没锻炼过身体… 你意识到, YOU CAN NOT DO THIS ALONE，你需要帮手，你需要找人一起把这个做下去。 但你不是要成为 Full Stack Engineer 么？你现在是了么？ Full Stack Engineer设计，后台开发，前端开发，移动开发，运营维护，PS，文案… 好像都会了，这算 Full Stack Engineer 了么？ 不，这只是踏上成为 Full Stack Engineer 的第一步。你知道目前只是每个 stack 都懂一点，离senior 或者 expert 还差得远，而要每个 stack 都做到极致，需要大量的时间和精力。精力有限，产品开发紧迫，力不从心啊，这条道路也太孤独，因为你不需要与任何人进行协作。难道要把一些stack的任务交给别人做么？这样算是放弃成为 Full Stack Engineer 么？ 不！这不是。什么是 Engineer？「Engineers are versatile minds who create links between science, technology, and society」。Engineer 的本质工作是设计，开发出应用于大众的产品。 一个真正的 Full Stack Engineer ，他从生活中发现问题，洞察需求，他设计解决方案，并开发出初始版本的产品。为了达到目标，他愿意去学习任何领域的技能和知识。同时他不追求一个人完成所有工作，如果有人可以比他在某方面做得更出色，便会十分热情的邀请他们加入。 最终他的职位也许不再是 Engineer ，他不再设计 UI ，不再写代码 … 他的工作不再是 design and building an app or product，因为他有更大更重要的任务要做 - design and building a team or a company which builds great products. 而这时，社会给了他们另一个称呼 - 创业者。尽管众人已忘记他们 Engineer 的身份，但在他们骨子里，内心深处，自己始终都是一个 Engineer 。当他们需要从头再来时，他们毫不犹豫从设计开发产品做起。Nikola Tesla，Ferdinand Porsche，Henry Ford，Jack Dorsey，Mark zuckerberg，Elon Musk … 细数那些改变了或正改变世界的创业者，他们大多数是 Engineer 背景，热衷于设计创造。他们学习技能和知识，不是为了成为某个领域的专家；而是因为那些 是完成自己目标所需要的。 以上，为我认可的 Full Stack Engineer]]></content>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
</search>
